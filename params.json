{"name":"Nanotwitter","tagline":"Nano Version of Twitter","body":"NanoTwitter\r\nShraddha Basnyat, Viet Le, Subahu Rayamajhi, Dewar Tan\r\n\r\n#Introduction\r\n\r\nThis is a nano version of [Twitter](https://twitter.com/) that we built for [COSI 105B: Software Development for Scability](http://bit.ly/cosi105b-2015) instructed by Pito Salas at Brandeis University.\r\n\r\nThe main purpose of this project is to apply scaling techniques that we learned in class to a live project under controlled environments.\r\n\r\n#Overview\r\n\r\nFollowing the project guidelines, our NanoTwitter has implemented these functionalities:\r\n\r\n- Users:\r\n  - can register for an account by supplying an email, an username, a full name and a password\r\n  - search for tweets\r\n\r\n- Logged in users\r\n  - Can follow and unfollow other registered users\r\n  - Can tweet\r\n  - Can see the flow of the last n tweets by the users that they have followed\r\n  - Can favorite and retweet any tweet\r\n\r\n- Non-logged in users\r\n  - See the flow of the last n tweets by any user\r\n\r\n- Tweets\r\n  - Consist of\r\n  \t- a 140 characters of text (HTML escape)\r\n  \t- a date-time of creation\r\n  - Belong to one user\r\n\r\nWe also provide REST API:\r\n\r\n- All stats with /api/v1\r\n- Tweets:\r\n  - /tweets/id\r\n  - /tweets/recent\r\n\r\n- Users:\r\n  - /users/id/tweets\r\n  - /users/id/followers\r\n  - /users/id/following\r\n  - /users/id/retweets\r\n  - /users/id/favorites\r\n    \r\nThe below screenshots represent our latest version of the application.\r\n\r\n1. Homepage:\r\n\r\n![homepage](http://i.imgur.com/zGNLAby.png)\r\n\r\n2. Signup page:\r\n\r\n![signup](http://i.imgur.com/THcqfOq.png)\r\n\r\n3. User page\r\n\r\n![user](http://i.imgur.com/k7RjRqh.png)\r\n\r\n4. Search results:\r\n\r\n![search](http://i.imgur.com/Ov5vhoh.png)\r\n\r\n#Load testing\r\n\r\nWe used [loader.io](http://loader.io/) to benchmark our app, connecting 500 users over the course of 1 minute.\r\n\r\nWe did 3 main load tests:\r\n\r\n1. GET / - load up homepage\r\n\r\n2. GET /user/testuser - load up testuser homepage\r\n\r\n3. POST /user/testuser/tweet - have testuser create 1 tweet\r\n\r\nOur final results are as followings:\r\n\r\n1. [Load homepage](http://ldr.io/1R64cug)\r\n\r\n<iframe width='600' height='300' frameborder='0' src='//share.loader.io/reports/326d3e59792e286c6e3a6936bd255bc0/widget/results/525308bcaeb7d9ca8ceb0fdeb5bd2b22'></iframe>\r\n\r\n2. [Load testuser homepage](http://ldr.io/1R64txh)\r\n\r\n<iframe width='600' height='300' frameborder='0' src='//share.loader.io/reports/ec8b10fecbee10a3074efb0f36718847/widget/results/ecec58927ccc777ef7097afadc954f1f'></iframe>\r\n\r\n3. [Testuser creates 500 tweets](http://ldr.io/1HRElDD)\r\n\r\n<iframe width='600' height='300' frameborder='0' src='//share.loader.io/reports/cb27819a66470efb424f5a6e4ac56934/widget/results/0667f4917a08bc366b257681ed8f23f8'></iframe>\r\n\r\n#Technology\r\n\r\n##Framework\r\n\r\nThe app was build on top of [Sinatra](http://www.sinatrarb.com/), a Ruby web framework, in [modular style](http://www.sinatrarb.com/intro.html#Sinatra::Base%20-%20Middleware,%20Libraries,%20and%20Modular%20Apps).\r\nA major advantage of writing this app in modular style is that each controller exists as an isolated Sinatra application.\r\n\r\nWe then use Rack Middleware to mount them to handle the corresponding URL requests.\r\n\r\n##Web Server\r\n\r\nWe migrated from Ruby default web server, WEBrick to [Puma](http://puma.io/) to take advantage of multithreads.\r\n\r\n##Database\r\n\r\nWe used [PostgreSQL](http://www.postgresql.org/) for storing persistent data.\r\n\r\n##Caching\r\n\r\nWe used [Redis](http://redis.io/) as caching backend.\r\nOn Heroku, we had 3 Redis stores; one for database query caching, one for [fragment caching](http://guides.rubyonrails.org/caching_with_rails.html#fragment-caching) and the last one for [sidekiq](http://sidekiq.org/).\r\n\r\nThe major improvement in response time comes from fragment caching.\r\nWe put the HTML code for a Tweet object in redis store so each time this object is called, the HTML is printed out.\r\nThis removes the overhead of connecting to database to get this Tweet object.\r\n\r\nIn one of our load testing, connecting 100 clients to the homepage over the course of 1 minute, the average response time before fragment caching was implemented was 146ms.\r\nAfter the fragment caching was introduced, the average time was reduced to 98ms.\r\n\r\n##Background jobs\r\n\r\nCreating a new user, a new tweet or a new follow are done asynchronously in the background.\r\nWe used [Sidekiq](http://sidekiq.org/) gem to achieve this.\r\n\r\n#Miscellaneous\r\n\r\n##CDN\r\n\r\nInstead of serving static assets from Heroku, we take advantage of public Content delivery networks (CDN) to serve [jQuery](https://jquery.com/) and [Bootstrap](http://getbootstrap.com/).\r\n\r\n##Compression\r\n\r\nWe use Rack::Deflater, a Rack middleware which intercepts responses, compressing them before sending them back to users.\r\nSmaller files mean faster response time for end users.\r\n\r\n##What could be done better\r\n\r\nWe used [PostgreSQL](http://www.postgresql.org/) on [Heroku](http://smalltwitter.herokuapp.com/) and [SQlite](https://www.sqlite.org/) because the former was easy to setup on our local machines.\r\nSQLite lacks a lot of bells and whistles which the former provides.\r\nBecause production and development environments are different, we didn't invest enough time on improving PostgreSQL\r\n\r\nA way to improve database performance is to replace ActiveRecord callbacks with [PostgreSQL triggers](http://www.postgresql.org/docs/current/static/plpgsql-trigger.html).\r\nCurrently we use callbacks to copy tweets from one user to all their followers.\r\nActiveRecord callbacks basically setup connections to database and run queries.\r\nImplementing this on PostgreSQL is faster because the application doesn't have to connect to databse and the queries are run internally inside PostgreSQL.\r\n\r\n[Sidekiq](http://sidekiq.org/) jobs run asynchronously, and non-sequentially.\r\nThere are libraries to make background jobs run sequentially.\r\nUsing these, we can have a single URL for creating a test case (reset testuser, seed tweets, seed users, seed followings...), instead of creating 1 job, checking status page to make sure that it is done before running another.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}